### PATTERN: DESIGN FOR IDEMPOTENCY ###

## Rationale 
In a complex architecture, complexity resides in the service interactions. What happens when services fail?

A service may go down in middle of a transaction due to a problem in a service further downstream. A mis-behaving service may be inadvertently (or deliberately) pounding a service with requests. A consuming service may experience latency in the network and may have timed out. The appropriate strategy to handle such failures is for consumers to retry. In this context, services must be designed to receive messages in "atleast-once" mode or expect duplicate requests. To tackle such "unexpected" behaviour, we need idempotent services.

The trigger may even be outside the application scope but triggered by changes in the cloud platform. In a recent case for a payment application, the cloud vendor as part of their routine internal maintenance tasks upgraded the managed load balancer instance to support http/2 protocol, which resulted in duplicate requests being sent by some clients. Further RCA conducted by the vendor determined that the issue was caused by incorrect handling of some specific headers by the load balancer. Analysis showed that clients were sending HTTP/2 requests, which were translated to the backend servers as HTTP/1.1 requests. When the load balancer received responses from backend servers, they contained some specific HTTP/1.1 headers which were incorrectly sent to the clients. This resulted in some clients, including those on iOS, sending duplicate requests while others, including Mac Safari, were not affected.

Since the downstream application was not designed to handle duplicate requests, this resulted in duplicate payments and a substantial business and reputation loss for the customer.

## Solution
A service is considered “idempotent” if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. Applicable for all services that mutate data (POST). Typically needed for services that change the functional state in a system. 

Following is one strategy that can be used to implement idempotent services:

Generate and track unique identifiers in the APIs you receive in your service request and eject those that have been processed successfully. The ids can be generated by the client. For server verification, the ids need to be stored in a short term or long term persistent storage such as cache or database. Use HTTP Header option such as "Idempotency-Key" to pass the id between client and server.

[Next - PATTERN: PROTECT USING BULKHEAD](https://github.com/srikanthkotekar/ideasworthsharing/blob/master/Building-Modern-Cloud-Native-Apps/5.10%20PATTERN:%20PROTECT%20USING%20BULKHEAD.md)

[Back to Pattern catalog](https://github.com/srikanthkotekar/ideasworthsharing/blob/master/Building-Modern-Cloud-Native-Apps/5.%20Cloud-Native%20Application%20Patterns.md)
